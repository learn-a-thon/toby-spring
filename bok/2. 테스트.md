# 2.0 서론
스프링은 `객체지향 기술`과 `테스트`, 두가지의 도구를 제공하여 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발할 수 있게 도와준다. 

# 2.1 UserDaoTest 다시보기
## UserDaoTest 소스코드
```java
public class UserDaoTest {
    public static void main(String[] args) {
        ConnectionMaker connectionMaker = new ConnectionMaker;

        UserDao dao = new UserDao(connectionMaker);

        ...
    }
}
```
> 코드 2-1

## 테스트의 유용성 
테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다. 
만약 결과가 제대로 나오지 않으면 결함이 있다는 것을 알 수 있다. 이를 통해서 결함을 제거해가며 최종적으로 테스트가 성공하면 결함이 제거됐다는 확신을 얻을 수 있다. 

## UserDaoTest의 특징
### 웹을 통한 테스트 방법의 문제점 
보통 웹 프로그램으로 테스트를 하기 위해서는 컨트롤러, 서비스 계층, 뷰 계층까지 포함한 기능들을 대충이라도 만들어야 한다. 또 결과를 화면에 출력해주는 기능을 만들어야 테스트 결과를 확인할 수 있다.

이러한 방법에는 문제점이 많다. DAO 뿐만 아니라, 그 외의 추가적인 부가 기능들도 만들어야 테스트가 가능하다. 또 만약에 테스트를 하다가 문제가 발생했다면 DAO만 확인해야할게 아니라, 서비스 계층, 컨트롤러 계층, 뷰 계층까지 모두 확인해야만 한다.

사실 테스트하고 싶었던 것은 UserDao 였는데 다른 계층의 코드 뿐만 아니라 서버의 설정상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 문제가 발생하면 정확하게 대응하기가 어렵다.

### 작은 단위의 테스트 
테스트하고자 하는 대상이 명확하다면, 그것에만 집중하는 것이 옳다. 관심사의 분리가 테스트에서도 적용이 된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 하나에만 집중하여 접근해야만 한다.

이렇게 작은 단위의 코드에 대해 테스트를 수행하는 것을 `단위 테스트`라고 한다. 
여기서 단위는 메서드가 될수도 있고, 하나의 기능이 될수도 있다. 일반적으로 단위는 작을수록 좋다. 단위를 벗어나는 다른 코드에 의존하지 않고 테스트가 동작하는 것이 좋다. 

기존의 UserDaoTest는 DB의 데이터에 따라 테스트의 결과가 달라진다. 보통 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트라고 하지 않는다.

물론 DB까지 접근해서 데이터를 등록하고, 그 다음 로직을 수행하는 긴 테스트도 필요하다. 하지만 이전에 단위 테스트가 이루어진 후 수행한다면 오류를 확인하는 과정이 훨씬 쉬워질 것이다. 

### 자동수행 테스트 코드
테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다. 왜냐하면 자주 반복할 수 있기 때문이다. 번거로운 작업이 없고 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 빠르게 테스트를 해볼 수 있다.

이러한 테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지 확인할 수 있다. 


## UserDaoTest의 문제점
### 수동 확인 작업의 번거로움
테스트를 수행하는 과정과 데이터 준비는 모두 자동으로 진행하지만 여전히 사람의 눈으로 확인해야하는 과정이 필요하다. 

### 실행 작업의 번거로움
간단히 실행 가능한 main() 메서드지만 수백개의 테스트가 된다면 번거로울 수 밖에 없다.

# 2.2 UserDaoTest의 개선
## 테스트 검증의 자동화 
테스트 중에 에러가 발생하는 것은 캐치하기 쉽다. 콘솔에 에러 메시지와 호출 스택이 출력되기 때문이다. 하지만 테스트가 실패하는 것은 별도의 확인 작업이 필요하다. 그래서 아래와 같이 코드를 작성해주면 확인 작업을 자동화 할 수 있다.
```java
if(user.getCode == null) {
    System.out.println("테스트 실패!");
}
else {
    System.out.println("테스트 성공!")
}
```
> 코드 2-2

## 테스트의 효율적인 수행과 결과 관리
테스트 검증까지 자동화하면서 UserDaoTest는 필요한 기능을 모두 갖춘 셈이다. 하지만 main() 메서드를 일일히 실행시켜주는 것은 부담스러운 작업이다. 이에 자바는 단순하면서도 실용적인 테스트를 위한 도구를 여러가지 제공하는데 보통 단위 테스트를 만들 땐 JUnit을 사용한다. 

### JUnit 테스트로 전환
JUnit은 프레임워크이다. 참고로 프레임워크는 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일을 스스로 수행한다. 그렇기 때문에 JUnit을 사용할때는 스스로 실행하기 위한 main() 메서드도 필요 없고, 오브젝트를 만들어서 실행시킬 필요도 없다. 

### 테스트 메소드 전환
JUnit이 실행시킬 테스트 메서드는 다음과 같은 두가지 조건이 존재한다. 
1. public
2. @Test 어노테이션
```java
@Test
public void addAndGet() {

}
```
> 코드 2-3

### 검증 코드 전환
Junit을 이용하여 검증 코드를 수정해보자 

```java
assertThat(user2.getName(), is(user.getName()));
```
> 코드 2-4
`assertThat()` 메서드는 첫번째 파라미터의 값을 두번째 파라미터에 나오는 매처라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만든다. `is()`는 매처의 일종으로 `equals()`로 비교해주는 기능을 가졌다.

JUnit을 사용하면 이제 "테스트 성공" 이라는 메시지를 확인할 필요가 없고, 테스트 결과를 다양한 방법으로 알려준다.

### JUnit 테스트 실행
스프링 컨테이너와 마찬가지로 JUnit 프레임워크도 자바 코드로 만들어진 프로그램 어디선가 한번 실행은 해줘야한다. JUnitCore 클래스의 main 메서드를 호출해주면 된다.

```java
public static void main(String[] args) {
    JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```
> 코드 2-5

# 2.3 개발자를 위한 테스팅 프레임워크 JUnit
## JUnit 테스트 실행 방법
JUnitCore를 이용해 테스트를 실행하면 결과를 확인하는건 간단하지만 테스트의 수가 많아지면 관리하기가 힘들다. 그래서 Java IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 방법이 있다. 

### IDE
보통 이클립스는 @Test가 들어 있는 테스트 클래스를 선택한 뒤에, 이클립스 run 메뉴의 Run As 항목 중 JUnit Test를 선택하면 메서드가 자동으로 실행된다. 테스트가 시작되면 JUnit의 결과를 알려주는 뷰가 나타나서 진행 결과를 알려준다. 

또 패키지를 클릭한 후 동일하게 JUnit Test를 선택하면 해당 패키지 아래 모든 테스트를 한번에 진행해준다. 

### 빌드 툴 
ANT나 메이븐 같은 빌드 툴과 스크립트를 사용하고 있다면 빌드 툴에서 제공하는 JUnit 플러그인이나 테스크를 이용해 JUnit 테스트를 실행할 수 있다. 테스트 실행 결과는 옵션에 따라서 HTML이나 텍스트 파일의 형태로 만들어진다.

## 테스트 결과의 일관성
UserDaoTest 테스트는 DB 상태에 따라 테스트가 성공하고 실패한다. 반복적으로 테스트를 실행했을 때 테스트가 실패하기도 성공하는 것은 좋은 테스트라고 할 수 없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야만한다. 

UserDaoTest의 문제점은 중복 데이터가 존재하여 실패할수도 있다는 것인데, 이것을 해결하기 위해서는 테스트를 실행하기전에 DB를 항상 동일한 상태로 만들어주면 된다.

따라서 우선 코드 2-6처럼 User 테이블의 모든 레코드를 삭제해주는 메서드와 User 테이블의 레코드 개수를 반환해주는 함수를 구현한다. 

```java
// User 테이블의 모든 레코드를 삭제한다.
public void deleteAll() {
    ...
}

// User 테이블의 레코드 개수를 반환한다.
public int getCount() {
    ...
}
```
> 코드 2-6

그리고 코드 2-7처럼 테스트 수행 전에 deleteAll을 수행하면 DB가 동일한 상태를 유지하기 떄문에 항상 동일한 결과의 Test를 만들 수 있다. 그리고 deleteAll() 메서드 또한 검증이 이루어져야 하기 때문에, getCount() 메서드를 활용하여 검증을 진행한다.
```java
@Test
public void addAndGet() {
    dao.deleteAll()
    assertThat(dao.getCount(), is(0));

    ...
}
```
> 코드 2-7

### 동일한 결과를 보장하는 테스트 
위의 과정을 통해 테스트가 어떤 상황에서 반복적으로 실행된다고 하더라도 동일한 결과가 나올 수 있게 됐다. 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안된다. DB에 남아 있는 데이터나 외부 환경에 영향을 받지 말아야하는 것도 물론이고, 테스트 실행 순서를 바꿔도 동일한 결과를 보장해야 한다. 

## 포괄적인 테스트
성의 없이 테스트를 만드는 바람에 문제가 있는 코드임에도 테스트를 통과하게 만드는 것은 위험하다. 특히 한 가지 결과만 검증하면 안된다. 
테스트 메서드는 한번에 한가지 검증 목적에만 충실하는 것이 좋다.

### getCount() 테스트 
getCount()를 위한 테스트 메서드를 따로 만들어보자 

```java
@Test
public void count() {
    UserDao dao = context.getBean("userDao", UserDao.class);
    User user1 = new User(...);
    User user2 = new User(...);
    User user3 = new User(...);


    dao.deleteAll();
    assertThat(dao.getCount(), is(0));

    dao.add(user1);
    assertThat(dao.getCount(), is(1));

    dao.add(user2);
    assertThat(dao.getCount(), is(2));

    dao.addd(user3);
    assertThat(dao.getCount(), is(3));

}
```
> 코드 2-8

### addAndGet() 테스트 보완 
add() 기능 테스트는 충분히 보완한 것 같은데, get() 기능은 테스트가 부족한 감이 있다. 파라미터로 주어진 id에 해당하는 사용자를 가져온 것인지, 아무거나 가져온 것인지 테스트에서는 검증하지 못했다. 


```java
User user1 = new User(...);
User user2 = new User(...);

dao.deleteAll();
assertThat(dao.getCount(), is(0));

dao.add(user1);
dao.add(user2);
assertThat(dao.getCount(), is(2));

User userget1 = dao.get(user1.getId());
assertThat(userget1.getName(), is(user1.getName()));
assertThat(userget1.getPassword(), is(user1.getPassword()));

User userget2 = dao.get(user2.getId());
assertThat(userget2.getName(), is(user2.getName()));
assertThat(userget2.getPassword(), is(user2.getPassword()));
```
> 코드 2-9

코드 2-9처럼 하면 문제를 해결할 수 있다.

### 예외에 대한 테스트 
```java
// 특별한 예외가 던져진다.
@Test(expected=UserDBException.class)
public void getUserFailure() {
    ...

    // 가져올 사용자 정보가 존재하지 않는 경우에
    dao.deleteAll();
    assertThat(dao.getCount(), is(0));

    // 존재하지 않는 id로 조회하면
    dao.get("unknown_id");
}
```
> 코드 2-10

예외 조건을 위한 테스트는 코드 2-10과 같이 expected 엘리먼트를 추가시켜주면 된다. 지정한 예외가 던져지면 테스트가 성공한다.

### 테스트를 성공하기 위한 코드의 수정
```java
public User get(String id) {
    ResultSet rs = ps.executeQuery(); 

    User user = null;
    if (rs.next()) {
        user = new User();
        user.setId(r.getString("id"));
        ...
    }

    rs.close();
    ps.close();

    if (user == null) throw new UserDBException();
    return user;
}   
```
> 코드 2-11
그런데 코드2-10의 예외 조건을 위한 테스트는 실패한다. UserDBException을 던져주는 부분이 없기 떄문이다. 따라서 위의 테스트를 성공시키기 위해 dao 코드를 코드 2-11처럼 수정해야 한다.

## 테스트가 이끄는 개발 
코드 2-10, 코드 2-11 과정을 보면 테스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 UserDao의 코드에 손을 대기 시작했다. 이런 순서를 따라서 개발을 진행하는 구체적인 개발 전략을 TDD라고 한다.

### 기능설계를 위한 테스트 
테스트할 코드도 없는데 어떻게 테스트 코드를 먼저 만들었을까? 코드를 보며 테스트를 어떻게 만들까? 라고 생각한 것이 아니라, 추가하고 싶은 기능을 코드로 표현하려 했기 때문에 가능했다. 코드 2-10의 테스트 코드는 잘 작성된 하나의 기능정의서처럼 보인다. 추가하고 싶은 기능을 테스트 코드로 표현하고 기능을 실제로 구현하면 테스트를 실행해서 바로 확인하면 된다. 기능 구현과 테스트라는 두 가지 작업이 동시에 끝나는 것이다. 

### 테스트 주도 개발 
만들고자 하는 기능의 내용을 담고 있고, 검증도 해주는 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도 개발이라고 한다.

"실패한 테스트를 성공하기 위한 목적이 아닌 코드는 만들지 않는다"가 TDD의 원칙이다. 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다. 

TDD의 장점은 코드를 만들어 테스트를 실행하는 그 사이의 간격이 굉장히 짧다는 것이 장점이다. 

## 테스트 코드 개선
테스트 코드도 언제든지 내부구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 코드로 만들 필요가 있다. 테스트 결과가 일정하게 유지된다면 얼마든지 리팩토링을 해도 좋다.

### @Before와 JUnit의 테스트 수행 순서
```java
public Class UserDaoTest {
    private UserDao dao;

    @Before
    public void setUp() {
        ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
        this.dao = context.getBean("userDao", UserDao.class);
    }
}
```
> 코드 2-12

1. @Test가 붙고, public 이고 void를 반환하는 파라미터가 없는 테스트 메서드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
- 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메서드를 사용하고 나면 버려진다.
    - 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실하게 보장하기 위해
3. @Before 붙은 메서드가 있으면 실행한다.
- 만약 일부에서만 공통적으로 사용되는 기능이 있다면 @Before이 아니라 메서드 분리 방법을 통해 분리한다.
- 혹은 별도의 테스트 클래스로 만드는 방법도 있다.
4. @Test가 붙은 메서드를 하나 호출하고 테스트 결과를 저장한다.
5. @After가 붙은 메서드가 있으면 실행한다. 
6. 나머지 테스트에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

### 픽스처
테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처라고 한다. 일반적으로 픽스처는 테스트에서 반복적으로 사용되기 때문에 @Before 메서드를 이용해 생성해두면 편리하다. 
```java
public class UserDaoTest {
    private UserDao dao;
    private User user1; 

    @Before
    public void setUp() {
        this.user1 = new User(...);        
    } // User 픽스처
}
```
> 코드 2-13

# 2.4 스프링 테스트 적용
@Before 메서드는 테스트 메서드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트 생성이 찜찜하다.애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다. 몇몇 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행하기 때문에 제법 많은 시간을 필요로 할 때도 있다.

또 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 리소스를 깔끔하게 정리해주지 않으면 다음 테스트에 영향을 줄수도 있다.

애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일은 거의 없다. 빈은 싱글톤이기 때문에 상태를 갖지 않는다. 따라서 애플리케이션 컨텍스트는 원칙과 다르게 여러 테스트가 공유해도 된다.

JUnit은 테스트 클래스 전체에 걸쳐 딱 한번만 실행되는 @BeforeClass라는 스태틱 메서드를 지원한다. 이 메서드를 통해 스태틱 변수에 저장해두고 테스트를 할 수도 있지만 이보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하는 것이 편리하다. 

## 테스트를 위한 애플리케이션 컨텍스트 관리
스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다.

### 스프링 테스트 컨텍스트 프레임워크 적용
```java
@RunWith(SpringJUnit4ClassRunner.class) 
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
    @Autowired
    private ApplicationContext context;

    @Before
    public void setUp() {
        this.dao = this.context.getBean("userDao", UserDao.class);
    }

}
```
> 코드 2-14

1. @RunWith은 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 에노테이션이다. SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.
2. @ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치이다.
3. 테스트 실행전 딱 한번만 애플리케이션 컨텍스트를 만들어두고 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것이다.

### 테스트 클래스의 컨텍스트 공유 
하나의 테스트 클래스 안에서만 공유되는 것이 아니라 모드 같은 설정파일을 사용한다면 다른 테스트 클래스끼리도 애플리케이션 컨텍스트를 공유한다.

### @Autowired
스프링은 애플리케이션 컨텍스트를 초기화할 때 자기 자신도 빈으로 등록하기 때문에 ApplicationContext도 DI가 가능한 것이다. 

## DI와 테스트
인터페이스를 두고 DI를 적용해야만 하는 이유는 뭘까? 
1. 소프트웨어 개발에서 절대 바뀌지 않는 것은 없다. 
2. 인터페이스를 두면 다른 차원의 서비스 기능을 도입할 수 있다. 1장의 카운터 기능이 예시이다.
3. 테스트 때문이다. DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 데 중요한 역할을 한다. 

### 테스트 코드에 의한 DI
DI는 애플리케이션 컨텍스트만 할 수 있는 작업이 아니다. 테스트 코드 내에서 직접 DI해도 된다. UserDao가 사용할 DataSource 오브젝트를 테스트 코드에서 변경할 수 있다. (운영DB -> 테스트DB)

```java 
dao.setDataSource(dataSource); // 코드에 의한 수동 DI 
```
> 코드 2-15

하지만 코드 2-15의 방식은 위험하다. 의존관계를 강제로 변경했기 떄문이다. 애플리케이션 컨텍스트는 공유되기 때문에 모든 테스트가 영향을 받는다.
@DirtiesContext를 이용하면 애플리케이션 컨텍스트를 새로 만들어 다음 테스트가 사용하게 할 수 있지만 조금 찜찜하다.

### 테스트를 위한 별도의 DI 설정
```xml
<bean id="dataSource" class="TestDataSource">
    <property name ="url" value="jdbc:testdb" />
</bean>
```
> 코드 2-16
테스트 전용 설정 파일 (test-applicationContext.xml)을 만드는 방법도 있다. 이는 모두 DI를 할 수 있도록 준비해둔 덕분에 사용할 수 있는 방법이다. 

### 컨테이너 없는 DI 테스트 
```java
@Before
public void setUp() {
    dao = new UserDao();
    DataSource dataSource = ...
    dao.setDataSource(dataSource);
}
```
> 코드 2-17
UserDao가 스프링의 API를 직접 이용한다거나 애플리케이션 컨텍스트를 이용하는 코드는 존재하지 않는다. 스프링 DI 컨테이너에 의존하지 않는다는 말이다. 
따라서 스프링 컨테이너를 사용하지 않고 테스트를 만들 수있다. 테스트 코드에서 직접 오브젝트를 만들고 DI해도 된다.
이것이 가능한 이유는 UserDao가 자신의 관심에만 집중하고 있기 때문이다.

코드 2-17처럼 깔끔하게 테스트를 만들 수 있는 이유는 DI를 적용했기 떄문이다. DI가 적용된 코드는 테스트에서도 다양한 방식으로 활용할 수 있을 만큼 유연하다. 두개의 모듈이 강하게 결합되어 있어 DI가 불가능한 구조로 만든다면 테스트할 때 불편해진다거나, 자동화된 테스트가 아예 불가능하지 않을까 의심해보자. 일반적으로 테스트하기 좋은 코드가 좋은 코드일 가능성이 높다.

### DI를 이용한 테스트 방법 선택
우선순위1. 스프링 컨테이너 없는 DI 테스트
우선순위2. 설정파일 분리
우선순위3. @DirtiesContext 사용

# 2.5 학습 테스트로 배우는 스프링
자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 하는데 이를 학습 테스트라고 한다.
학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다. 학습 테스트는 테스트 대상보다는 테스트 코드 자체에 관심을 갖고 만들어야 한다.

## 학습 테스트의 장점 
1. 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
2. 나중에 참고할 수 있다.
3. 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
4. 테스트 작성에 좋은 훈련이 된다.
5. 새로운 기술을 공부하는 과정이 즐거워진다.

## 버그 테스트
버그테스트란 코드에 오류가 있을 때 그 오류를 가장 잘 드러낼 수 있는 테스트를 말한다. 버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 되서 테스트가 실패한 코드를 만드는 것이다. 그리고 나서 버그 테스트가 성공할 수 있도록 어플리케이션 코드를 수정한다. 테스트가 성공하면 버그는 해결된 것이다. 

### 버그 테스트의 장점
1. 테스트의 완성도를 높여준다.
2. 버그의 내용을 명확하게 분석하게 해준다. 
- 실패하게 하려면 어떤 이유 때문에 문제가 생겼는지 알아야 하기 떄문이다.
3. 기술적인 문제를 해결하는데 도움이 된다.
- 별다른 문제가 없는 것처럼 느껴지거나 또는 기술적으로 다루기 힘든 버그를 발견하는 경우 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다.