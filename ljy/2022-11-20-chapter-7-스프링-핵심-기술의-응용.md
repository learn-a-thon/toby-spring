# 스프링 핵심 기술의 응용

## 7.1 SQL과 DAO의 분리
DB 테이블과 필드 정보를 고스란히 담고 있는 SQL 문장을 분리한다.

## 7.1.2 SQL 제공 서비스
스프링의 설정파일 안에 SQL을 두고 이를 DI 해서 DAO가 사용하게 하면 손쉽게 SQL을 코드에서 분리해낼 수 있긴 하지만 본격적으로 적용하기엔 몇 가지 문제점이 있다. 
 - 스프링 설정파일로부터 생성된 오브젝트와 정보는 애플리케이션을 다시 시작하기 전에는 변경이 매우 어렵다.
 - 싱글톤인 DAO의 인스턴스 변수에 접근해서 실시간으로 내용을 수정하는 건 간단한 일이 아니다.
 - 빈전하게 참조되는 내용을 수정할 경우 동시성 문제를 일으킬 수도 있다. 

### 서비스 인터페이스 
가장 먼저 할 일은 서비스 인터페이스를 설계하는 것이다. DI로 구현 클래스의 오브젝트를 주입해주어야 한다는 사실을 바로 떠올릴 수 있을 것이다. 
```java
public interface SqlService {
    String getSql(String key) throws SqlRetrievalFailureException;
}
```

### 스프링 설정을 사용하는 단순 SQL 서비스
가장 간단한 방법으로 SqlSErvice를 구현해보자. SqlSErviec 인터페이스를 구현하는 클래스를 만들고 Map 타입 프로퍼티를 추가한다. 

```java
public class SimplSqlService implements SqlService {
    private Map<String, String> sqlMap;

    public void setSqlMap<Map<String, String> sqlMap> {
        this.sqlMap = sqlMap;
    }

    public String getSql(STring key) throws SqlRetrievalFailureException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlRetrievalFailureException(key + "에 대한 sql를 찾을 수 없습니다.");
        } else {
            return sql;
        }
    }
}
```
구체적인 구현 방법과 기술에 상관없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면된다. 동시에 sqlService 빈에는 DAO에 전혀 영향을 주지 않는 채로 다양한 방법으로 구현된 SqlService 타입 클래스를 적용할 수 있다.

## 7.2 인터페이스의 분리와 자기참조 빈

## 7.2.1 XML 파일 매핑
스프링의 MXML 설정파일에서 <bean> 태그 안에 SQL 정보를 넣어놓고 활용하는 건 좋은 방법이 아니다. 그 보다는 SQL을 저장해두는 전용 포맷을 가진 독립적인 파일을 이용하는 편이 낫다. 

### JAXB
XML에 담긴 정보를 파일에서 읽어오는 방법은 다양하지만 여기서는 가장 간단한게 사용할 수 있는 JAXB를 이용한다.  
DOM과 같은 전통적인 XML API와 비교했을 때 JAXB의 장점은 XML 문서접오를 거의 동일한 구조의 오브젝트로 직접 매핑해준다는 것이다. API는 어노테이션에 담긴 정보를 이용해서 XML과 매핑된 오브젝트 트리 사이의 자동변환 작업을 수행해준다.
![](https://velog.velcdn.com/images/nunddu/post/138c83d6-c920-4421-859d-cef1a5ef82ee/image.png)

```java
// SqlmapType 클래스
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "sqlmapType", propOrder = { "sql" })
    @XmlRootElement(name = "sqlmap")
    public class Sqlmap {
        @XmlElement(required = true)
        protected List<SqlType> sql;

        public List<SqlType> getSql() {
            if (sql == null) {
                sql = new ArrayList<SqlType>();
            }
            return  this.sql;
        }
    }
```

```java
// SqlType 클래스
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "sqlType", propOrder = { "value" })
    public class SqlType {
        @XmlValue
        protected String value;
        @XmlAttribute(required = true)
        protected String key;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }

        public String getKey() {
            return key;
        }

        public void setKey(String value) {
            this.key = value;
        }
    }

```

## 7.2.2 XML 파일을 이용하는 SQL 서비스 
### XML SQL 서비스 
특별한 이유가 없는 한 XML 파일은 한 번만 읽도록 해야하낟. XML 파일로 부터 읽은 내용은 어딘가에 저장해두고 DAO에서 요청이 올 때 사용해야한다. SqlService를 구현한 클래스는 스프링이 관리하는 빈으로 등록이 될 것이다. 스프링이 언제 어떻게 빈 오브젝트를 생성할 지 알 수 없으니 일단은 간단히 생성자에서 SQL을 읽어와 내부에 저장해두는 초기 작업을 하자. 
```java
// 생성자 초기화 방법을 사용하는 XmlSqlService 클래스
public class XmlSqlService implements SqlService {

    private final Map<String, String> sqlMap = new HashMap<>();

    public XmlSqlService() {
        String contextPath = Sqlmap.class.getPackage().getName();
        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream("sqlmap.xml");
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(getXmlFile(is));

            for (SqlType sql : sqlmap.getSql()) {
                sqlMap.put(sql.getKey(), sql.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }

    public String getSql(String key) throws SqlRetrievalFailureException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlRetrievalFailureException(key + "에 대한 sql를 찾을 수 없습니다.");
        } else {
            return sql;
        }
    }
}
```
DBA에 의한 SQL 리뷰나 튜닝이 필요하다면 sqlmap.xml 파일만 제공해주면된다. 애플리케이션의 코드나 DI 설정은 전혀 수정할 필요가 없어졌다. 

## 7.2.3 빈의 초기화 작업
XmlSqlService 코드를 다시 한 번 살펴보자. 몇 가지 개선했으면 하는 점이 눈에 띈다. 생성자에서 예외가 발생할 수도 있는 복잡한 초기화 작업을 다루는 것은 좋지 않다. 일단 초기 상태를 가진 오브젝트를 만들어놓고 별도의 초기화 메소드를 사용하는 방법이 바람직하다. 

```java
public void laodSql() {
    String contextPath = Sqlmap.class.getPackage().getName();
    try {
        ...
        InputStream is = UserDao.class.getResourceAsStream(this.sqlmapFile);
        ...
    }
}
```
외부에서 파일을 지정할 수 있고, 이를 이용해 SQL을 읽어들이는 초기화 작업을 담당할 메소드도 별도로 만들었다. XmlSqlService 오브젝트는 빈이므로 제어권이 스프링에 있다. 생성은 물론이고 초기화도 스프링에 맡길 수 밖에 없다. 그래서 **스프링은 빈 오브젝트를 생성하고 DI 작업을 수행해서 프로퍼티를 모두 주입해준 뒤에 미리 지정한 초기화 메소드를 호출해주는 기능을 갖고 있다.**  
@PostConstruct 어노테이션을 빈 오브젝트의 ㅈ초기화 메소드를 지정하는 데 사용한다. DI 작업을 마친 뒤에 메소드를 자동으로 실행해준다. 생성자와는 달리 프로퍼티까지 모두 준비된 후에 실행된다는 면에서 @PostConstruct 초기화 메소드는 매우 유용하다.

## 7.2.4 변화를 위한 준비 : 인터페이스 분리
XML 대신 다른 포맷의 파일에서 SQL을 읽억오게 하려면 어떻게 해야할까? SqlService인터페이스를 구현하는 완전히 새로운 클래스를 처음부터 만들거나 XmlSqlService의 코드를 직접 고쳐야 한다. 코드에 영향을 주지 않으면서 유연하게 확장 가능하도록 DI를 적용해보자.

### 책임에 따른 인터페이스 정의 
가장 먼저 할일은 분리 가능한 관ㅅ미사를 구분해보는 것이다. XmlSqlService 구현을 참고해서 독립적으로 변경 가능한 책임을 뽑아보자. 
 - Sql 정보를 외부의 리소스로부터 읽어노는 것
 - Sql을 보관해두고 있다가 필요할 때 제공해주는 것

JAXB에서 만들어준 Sql 클래스를 사용하는 것은 곤란하다. 범용적인 인터페이스를 JAXB라는 특정 구현에 의존하도록 정의해서는 안되기 때문이다. 
SqlReader는 내부에 갖고 있는 SQL 정보를 형식을 갖춰서 돌려주는 대신, 협력 관계에 있는 의존 오브젝트인 SQlRegistry에게 필요에 따라 등록을 요청할 때만 활용하면 된다.   

![](https://velog.velcdn.com/images/nunddu/post/a3d5d1ec-e0e2-4ca5-88f5-0827204a2644/image.png)  

### SqlRegistry 인터페이스
```java
public interface SqlRegistry {
    void registerSql(String key, String sql);
    String findSql(String key) throws SqlNotFoundException;
}
```

### SqlReader 인터페이스
```java
public interface SqlReader {
    void read(SqlRegistry sqlRegistry);
}
```

## 7.2.5 자기참조 빈으로 시작하기
### 다중 인터페이스 구현과 간접 참조
SqlService의 구현 클래스는 이제 SqlReader와 SqlRegistry 두 개의 프로퍼티를 DI 받을 수 있는 구조로 만들어야 한다.   
![](https://velog.velcdn.com/images/nunddu/post/8ea715b2-98c4-4ad7-b5e4-857ae7e2218b/image.png)

클래스의 코드는 단지 인터페이스에 대해서만 알고 있고, 인터페이스를 통해서만 의존 오브젝트에 접근한다. 그저 DI 받은 오브젝트를 사용하기만 하면 된다.  
클래스를 상속하는 것과 마찬가지로 인터페이스를 구현하는 경우에도 구현 클래스는 인터페이스의 타입을 그대로 물려받는다. 그 덕분에 같은 타입으로 존재하지만 다른 구현을 가진 오브젝트를 만들 수 있다는 다형성을 활용할 수 있는 것이다. 따라서 XmlSqlService 클래스 하나가 `SqlService`, `SqlReader`, `SqlRegistry`라는 세 개의 인터페이스를 구현해도 된다. 

### 인터페이스를 이용한 분리
```java
public class XmlSqlService implements SqlService {
    @Setter
    private SqlReader sqlReader;
    @Setter
    private SqlRegistry sqlRegistry;
}
```
마찬가지로 SqlReader의 구현 코드에서 SqlRegistry 구현 코드로 내부 정보에 접근하면 안된다. 인터페이스에 정의된 메소드를 통해서만 사용해야한다. 

```java
// SqlService 인터페이스 구현 부분
public class XmlSqlService implements SqlService, SqlRegistry, SqlReader {
    @PostConstruct
    public void loadSql() {
        this.sqlReader.read(this.sqlRegistry);
    }

    public String getSql(String key) throws SqlRetrievalFailureException {
        try {
            return this.sqlRegistry.findSql(key);
        } catch(SqlNotFoundException e) {
            throw new SqlRetrievalFailureException(e);
        }
    }
}
```

## 7.2.6 디폴트 의존관계
다음은 분리된 인터페이스들을 통해 DI로 조합해서 사용하게 만드는 단계다.

### 확장 가능한 기반 클래스
SqlRegistry와 SqlReader를 이용하는 가장 간단한 SqlService 구현 클래스를 만들어보자.

```java
public class BaseSqlService implements SqlService {
    protected SqlReader sqlReader;
    protected SqlRegistry sqlRegistry;

    public void setSqlReader(SqlReader slqReader) {
        this.sqlReader = sqlReader;
    }
    
    pbulic void setSqlRegistry(SqlRegistry sqlRegistry) {
        this.sqlRegistry = sqlRegistry;
    }

    @PostConstruct
    public void loadSql() {
        this.sqlReader.read(this.sqlRegistry);
    }

    public String getSql(String key) throws SqlRetrievalFailureException {
        try { return this.sqlRegistry.findSql(key); }
        catch(SqlNotFoundException e) {
            throw new SqlRetrievalFailureException(e);
        }
    }
}
```

### 디폴트 의존관계를 갖는 빈 만들기
BaseSqlService는 sqlReader와 sqlRegistry 프로퍼티의 DI를 통해 의존관계를 자유롭게 변경해가면서 기능을 확장할 수 있다. 유연성을 보장하려면 이런 구족 ㅏ꼭 필요하지만, 반대로 적어도 3개의 빈을 등록해줘야한다는 점이 귀찮을 수도 있다. 하지만 **설령 한동안은 JAXB를 사용하는 SqlReader와 HashMap으로 저장해두는 SqlRegistry를 사용할 것이 분명하다고 해도 말이다. 특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라고 해도 좋을 만큼 기본적으로 사용될 가능성이 있다면, 디폴트 의존관계를 갖는 빈을 만드는 것을 고려해볼 필요가 있다.**


```java
// 생성자를 통한 디폴트 의존관계 설정

public class DefaultSqlService extends BaseSqlService {
    public DefaultSqlService() {
        setSqlReader(new JaxbXmlSqlReader());
        setSqlRegistry(new HashMapSqlRegistry());
    }
}

이렇게 자신이 사용할 디폴트 의존 오브젝트를 DI하는 방법이 있다. 하지만 빈으롣 등록되는 것은 DefaultSqlService뿐이기 때문에 어떤 파일에서 Sql을 읽어올지 알 수 없어 에러가 발생한다.  
JaxbXmlSqlReader의 sqlmapFile에 디폴트 이름을 넣어주자.

```java
private static final String DEFAULT_SQLMAP_FILE = "sqlmap.xml";
```
DefaultSqlService처럼 자주 사용되는 의존 오브젝트는 미리 지정한 디폴트 의존 오브젝트를 설정없이도 사용할 수 있게 만드는 것도 좋은 방법이다. 