## 5.1 사용자 레벨 관리 기능 추가
지금까지의 UserDao는 User 오브젝트에 담겨이쓴 사용자 정보를 CRUD하는 작업만 가능하다. 아래 간단한 비즈니스 로직을 추가해보자 
 - 사용자 레벨은 `BASIC`, `SILVER`, `GOLD`
 - 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 한 단계씩 업그레이드 될 수 있다.
 - 가입 후 50회 이상 로그이늘 하면 BASIC에서 SILVER 레벨이 된다.
 - SILVER에서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
 - 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다. 

## 5.1.1 필드 추가
DB에 varchar 타입으로 선언 후 `BASIC`, `SILVER`, `GOLD` 문자를 넣는 방법도 있겠지만, 별로 좋아보이지 않는다. 각 레벨을 코드화해서 숫자로 넣는 방법을 고려해보자 범위가 작은 숫자로 관리하면 DB 용량도 많이 차지하지 않고 가벼워서 좋다. 그렇다면 자바의 User에 추가할 프로퍼티 타입도 숫자로 하기에는 타입이 안전하지 않아서 좋지 않다. 

```java
public void setLevel(int level) {
    this.level = level;
}
```
level이 int이기 때문에 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다. 레벨과 관련이 없는 int값이 들어갈 가능성이 있다. 그래서 enum을 이용하는게 안전하고 편리하다.
 
 ```java
public enum Level {
    BASIC(1), SILVER(2), GOLD(3);

    private final int value;

    Level (int value) { // DB에 값을 넣어줄 생성자를 만듦
        this.value = value;
    }

    public int intValue() {
        return value;
    }

    // 값으로부터 Level 타입 오브젝트를 가져오도록 만든 스태틱 메소드
    public static Level valueOf(int value) { 
        switch(value) {
            case 1: return BASIC;
            case 2: return SILVER;
            case 3: return GOLD;
            default: throw new AssertionError("Unknown value: " + value); 
        }
    }
}
 ```
 enum은 DB에 저장할 int 타입을 값을 가지고 있지만, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하기 사용할 수 있다. 
 
 ```java
 private void checkSameUser(User user1, User user2) {
    assertThat(user1.getId(), is(user2.getId()));
    assertThat(user1.getName(), is(user2.getName()));
    assertThat(user1.getPassword(), is(user2.getPassword()));
    assertThat(user1.getLevel(), is(user2.getLevel()));
    assertThat(user1.getLogin(), is(user2.getLogin()));
    assertThat(user1.getRecommend(), is(user2.getRecommend()));
 }
 ```
 검증용 필드를 추가해서 기존에 만들었던 DAO 테스트 기능을 보완한다. 이를 빼먹으면 새로 추가된 필드의 DB 쓰기와 읽기가 바르게 되는지 검증되지 않는다. 수정된 checkSameUser() 메소드를 이용하는 테스트 코드로 수정한다.


 ```java
@Test
public void addAndGet() {
    ...
    User userget1 = dao.get(user1.getId());
    checkSameUser(userget1, user1);

    User userget2 = dao.get(user2.getId());
    checkSameUser(userget2, user2);
}
 ```
 
이제 준비된 테스트가 성공하도록 USerDaoJsdbd 클래스를 수정해보자. User 오브젝트 매핑용 콜백인 userMapper에 추가된 필드를 넣는다.

```java
public class UserDaoJdbc implements UserDao {
    ...
    private RowMapper<User> userMapper = new RowMapper<User>() {
        public User mapRow(ResultSet rs, int rowNum) throws SQLException {
            User user = new User();
            user.setId(rs.getString("id"));
            user.setName(rs.getString("name"));
            user.setPassword(rs.getString("password"));
            user.setLevel(Level.valueOf(rs.getInt("level")));
            user.setLogin(rs.getInt("login"));
            user.setRecommend(rs.getInt("recommend"));
            return user;
        }
    };
  
    public void add(User user) {
        this.jdbcTemplate.update(
            "insert into users(id, name, password, level, login, recommend) values(?, ?, ?, ?, ?, ?)", 
            user.getId(), user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend());
    }
}
```
여기서 눈여겨볼 것은 Level 타입의 level 필드를 사용하는 부분이다. Level enum 자체는 DB에 저장될 수 있는 SQL 타입이 아니다. 따라서 DB에 저장 가능한 정수형 값으로 먼저 변환을 해줘야한다. 


위 테스트 결과 `BadSqlGrammarException`이 발생한다. SQL은 컴파일 과정에서 자동으로 검증이 되지 않는 단순 문자열에 불과하다. 따라서 DB에 전달되기 까지는 문법 오류나 오타조차 발견하기 힘들다. 미리미리 DB까지 연동되는 테스트를 잘 만들어 두어야 오타를 빠르게 잡아낼 수 있다. 
그런데 자주 실행해볼 수 있는 테스트가 없는채로 사용자 정보에 새로운 필드가 추가됐다면? 누군가 실제 사용 전까지 오타조차 발견하기 힘들것이다. 
**에러 발생 이후 에러 메세지를 보고 서버 배치, 서버 재시작, 수동 테스트 등에 소모한 시간은 낭비에 가깝다. 빠르게 실행 가능한 포괄적인 테스트를 만들어두면 이렇게 기능의 추가나 수정이 일어날 때 그 위력을 발휘한다.**

## 5.1.2 사용자 수정 기능 추가
수정할 정보가 담긴 User 오브젝트를 전달하면 id를 참고해서 사용자를 찾아 필드 정보를 UPDATE 문을 이용해 모두 변경해주는 메소드를 만들어보자

### 수정 기능 테스트 추가
```java
@Test
public void update() {
    daou.deleteAll();

    daou.add(user1);

    user1.setName("오민규");
    user1.setPassword("springno6");
    user1.setlevel(Level.GOLD);
    user1.setLogin(1000);
    user1.setRecommend(999);
    dao.update(user1);

    User user1update = dao.get(user1.getId());
    checkSameUser(user1, user1update);
}

```

먼저 User 오브젝트를 하나 등록하고 id를 제외한 필드의 내용을 바꾼 뒤 update()를 호출한다. 이제 해당 id의 사용자 정보가 변경됐어야 한다. 다시 id로 조회해서 가져온 User 오브젝트와 수정한 오브젝트를 비교한다. 

### UserDao와 UserDaoJdbc 수정
UserDao 인터페이스에 update 메소드가 없기 때문에 추가주고 UserDaoJdbc에 메소드를 구현도 작성한다. 

```java
public interface UserDao {
    ...
    public void update(User user);
}
```

```java
public void update(User user) {
    this.jdbcTemplate.update(
        "update users set name = ?, password = ?, level = ?, login = ?, recommend = ?, where id = ?", 
        user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend(), user.getId());
}
```

### 수정 테스트 보완
가장 실수가 많이 일어나는 곳은 SQL 문장이다. 필드 이름이나 SQL 키워드를 잘못 넣었다면 텟트트를 돌려보면 에러가 나니 쉽게 확인할 수 있지만 위 테스트 코드가 검증하지 못하는 부분이 있을 수 있다. 
Update 문장에서 where 조건을 빼먹는 경우 아무런 경고 없이 정상적으로 동작할 수 있다. 

**첫 번째 해결 방법**은 JdbcTemplate의 update()가 돌려주는 리턴값을 확인하는 것이다. jdbcTemplate의 update()는 수정, 삭제 같이 테이블의 내용에 영향을 주는 SQL을 실행하면 영향 받은 로우의 개수를 돌려준다. 

**두 번째 방법**은 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것이다. 
```java
// 보완된 update() 테스트
@Test
public void update() {
     dao.deleteAll();
    
    dao.add(user1); // 수정할 사용자
    dao.add(user2); // 수정하지 않는 사용자
  
    user1.setName("오민규");
    user1.setPassword("springno6");
    user1.setLevel(Level.GOLD);
    user1.setLogin(1000);
    user1.setRecommend(999);
  
    dao.update(user1);
    
    User user1update = dao.get(user1.getId());
    checkSameUser(user1, user1update);
    User user2same = dao.get(user2.getId());
    checkSameUser(user2, user2same);
}

```

## 5.1.3 UserService.upgradeLevels()
비즈니스 로직은 어디다 두는 것이 좋을까? DAO는 데이터를 가져오고 조작하고 다루는 곳이기 때문에 비즈니스 로직을 두기에는 부적합하다. 비즈니스 로직 서비스를 제공한다는 의미에서 `UserSevice` 클래스를 만든다. 

### UserService 클래스와 빈 등록
```java
...
public class UserService {
    UserDao userDao;
    
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

```java
<bean id="userService" class="springbook.user.service.UserService">
    <property name="userDao" ref="userDao" />
</bean>

<bean id="userDao" class="springbook.dao.UserDaoJdbc">
    <property name="dataSource" ref="dataSource" />
</bean>
```

### UserServiceTest 테스트 클래스
UserServiceTest 클래스를 추가하고 테스트 대상인 UserService 빈을 제공받을 수 있도록 @Autowired가 붙은 변수로 선언해준다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/test-applicationContext.xml")
public class UserServiceTest {
    @Autowired
    UserService userService;
    
    @Test
    public void bean() {
        assertThat(this.userService, is(notNullValue()));
    }
}
```
테스트 메소드를 통해 테스트가 성공하면 UserService 빈이 잘 등록됐음을 알 수 있다.

### upgradeLevels() 메소드
```java
public void upgradeLevels() {
    List<User> users = userDao.getAll();
    for (User user : users) {
        Boolean changed = null; // 레벨의 변화가 확인용 플래그
        
        if (user.getLevel() == Level.BASIC && user.getLogin() >= 50) { // BASIC 레벨 업르게리드 로직
            user.setLevel(Level.SILVER);
            changed = true;
        } else if (user.getLevel() == Level.SILVER && user.getRecommend() >= 30) { // SILVER 레벨 업르게리드 로직
            user.setLevel(Level.GOLD);
            changed = true;
        } else if (user.getLevel() == Level.GOLD) {
            changed = false;
        } else {
            changed = false;
        }
        
        if (changed) {
            userDao.update(user);
        }
    }
}
```
모든 사용자 정보를 DAO에서 가져온 후 한명씩 레벨에 관련된 비즈니스 로직을 돌면셔 해동 조건에 부합하면 레벨을 변경한다. 

## 5.1.4 UserService.add()
처음 가입하는 사용자는 기본적으로 BASIC 레벨이어야한다는 부분이 남았다. UserDaoJdbc는 DB에 정보를 넣고 읽는 방법에만 관심을 가져야하고, User 클래스에 level 필드를 초기화해두는 것은 처음 가입할 때 외에는 무의미하다는 느낌이 있다. UserService에 이 로직을 넣는 방향을 고려해보자.

```java
@Test
void add() {
    userDao.deleteAll();

    User userWithLevel = userList.get(4);
    User userWithoutLevel = userList.get(0);
    userWithoutLevel.setLevel(null);

    userService.add(userWithLevel);
    userService.add(userWithoutLevel);

    User userWithLevelRead = userDao.get(userWithLevel.getId());
    User userWithoutLevelRead = userDao.get(userWithoutLevel.getId());

    assertThat(userWithLevelRead.getLevel()).isEqualTo(userWithLevel.getLevel());
    assertThat(userWithoutLevelRead.getLevel()).isEqualTo(Level.BASIC);
}
```
레벨이 미리 정해진 경우와 레벨이 비어 있는 두 가지 경우에 대해 각각 add() 메소드를 호출하고 결과를 확인해보자. 


```java
// 사용자 신규 등록 로직을 담은 add() 메소드
public void add(User user) {
    if (user.getLevel() == null) user.setLevel(Level.BASIC);
    userDao.add(user);
}
```

## 5.1.5 코드 개선
코드 개선을 위해 아래와 같은 내용을 생각해보자
 - 코드에 중복된 부분은 없는가?
 - 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
 - 코드가 자신이 있어야할 자리에 있는가?
 - 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

### upgradeLevels() 메소드 코드의 문제점
작성된 upgradeLevels() 메소드는 for 루프 안에 if,else,else if 블록들이 가독성을 안좋게 만들고, 성격이 다른 여러 가지 로직이 한데 섞여인느 문제점이 있다. 

### upgradeLevels() 리팩토링
```java

public void upgradeLevels() {
    List<User> users = userDao.getAll();
    for (User user : users) {
        if (canUpgradeLevel(user)) {
            upgradeLevel(user);
        }
    }
}
```
upgradeLevels() 메소드는 사용자 정보를 가져와 한 명씩 업그레이드가 가능한지 확인하고, 가능하면 업그레이드를 한다는 간단한 작업을 하도록 수정하고 구체적인 구현을 기능은 메소드로 분리한다. 

```java
private boolean canUpgradeLevel(User user) {
    Level currentLevel = user.getLevel();
    switch (currentLevel) {
        case BASIC:
            return (user.getLogin() >= 50);
        case SILVER:
            return (user.getRecommend() >= 30);
        case GOLD:
            return false;
        default:
            throw new IllegalArgumentException("Unknown Level:" + currentLevel); 
    }
}
```
사용자의 레벨에 따라 업그레이드가 가능한 지 체크하는 메서드를 만들고 가능 여부를 반환한다. 

```java
private void upgradeLevel(User user) {
    if (user.getLevel() == Level.BASIC) user.setLevel(Level.SILVER);
    else if (user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);
    userDao.update(user);
}
```
이 코드는 다음 레벨에 대한 로직과 필드를 변경하는 로직이 함께 있는데다가 예외에 대한 처리가 없다.

```java
public enum Level {
    GOLD(3, null), SILVER(2, GOLD), BASIC(1, SILVER);

    private final int value;
    private final Level next;
}
```
Level enum에 next라는 다음 단계 레벨 정보를 추가한다. 이렇게 하면 DB에 저장될 값과 다음 레벨이 무엇인지를 함께 넣어줄 수 있다. **UserService가 일일이 레벨 업그레이드 시에 User의 어떤 필드를 수정한다는 로직을 갖고 있기보다는, User에게 레벨 업그레이드를 해야하니 정보를 변경하라고 요청하는 편이 낫다.** 

```java
// User의 레벨 업그레이드 작업용 메소드
public void upgradeLevel() {
    Level nextLevel = this.level.nextLevel();
    if (nextLevel == null) {
         throw new IllegalStateException(this.level + "은 업그레이드가 불가능합니다");
    } else {
        this.level = nextLevel;
    }
}
```

```java
// 간결해진 upgradeLevel()
private void upgrade(User user) {
    user.upgradeLevel();
    userDao.update(user);
}
```
if 문장이 많이 들어있던 이전 코드보다 간결하고 작업 내용이 명확하게 드러나는 코드가 됐다. 

