###### 2장 테스트
# 2.4. 스프링 테스트 적용

이제 테스트 코드가 어느 정도 깔끔해졌지만, 여전히 한 가지 찜찜한 부분이 남아 있다. `@Before` 메소드가 테스트 메소드 개수만큼 반복되므로 애플리케이션 컨텍스트도 세 번 만들어진다는 것이다. 
기본적으로 애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화하는데, 빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다. 
뿐만 아니라, 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 해서, 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스 
등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있다.           

이처럼 생성에 많은 시간과 자원이 소모되는 애플리케이션 컨텍스트와 같은 경우에는 *테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어 사용한다*는 기존 원칙과 반대로, 
테스트 전체가 공유하는 오브젝트를 만들기도 한다. 스프링이 제공하는 테스트 컨텍스트 프레임워크의 지원을 받으면 간단한 애노테이션 설정만으로 애플리케이션 컨텍스트를 만들어 모든 테스트가 공유하게 할 수 있다. 

<br/>

### 스프링 테스트 컨텍스트 프레임워크 적용 

`UserDaoTest`에 스프링의 테스트 컨텍스트 프레임워크를 적용해보자. 

먼저 `@Before` 메소드에서 애플리케이션 컨텍스트를 생성하는 코드를 제거하고, 테스트 클래스에 다음의 애노테이션들을 추가한다.
```java
@RunWith(SpringJUnit4ClassRunner.class) // 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능 지정
@ContextConfiguration(locations="/applicationContext.xml") // 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정, 클래스간의 공유도 가능하다. 
public class UserDaoTest {
    @Autowired
    private ApplicationContext context;
    
    ...
    
    @Before
    public void setUp() {
        System.out.println(this,context); // 매번 같다.
        System.out.println(this);         // 매번 다르다.
        this.dao = this.context.getBean("userDao", UserDao.class);
    }
}
```
`@RunWith`는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다. `SpringJUnit4ClassRunner`라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 
JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다. 따라서 인스턴스 변수인 `context`를 따로 초기화해주지 않아도 테스트는 
`NullPointerException` 없이 정상적으로 동작한다.     

<br/>

> **@Autowired**
>                                       
> `@Autowired`는 스프링의 DI에 사용되는 특별한 애노테이션이다. `@Autowired`가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 
> 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다. 일반적으로 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만, 이 경우에는 메소드가 없어도 주입이 가능하다. 
> 또 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있는데, 이런 방법을 *타입에 의한 자동와이어링*이라고 한다.             
> `@Autowired`를 이용해 애플리케이션 컨텍스트가 갖고 있는 빈을 DI 받을 수 있다면 굳이 컨텍스트를 가져와 `getBean()`을 사용하는 것이 아니라, 아예 `UserDao` 빈을 직접 DI 받을 수도 있을 것이다. 
> ```java
> ...
> public class UserDaoTest {
>     @Autowired
>     UserDao dao;
> }
> ```
> `@Autowired`를 지정하기만 하면 어떤 빈이든 다 가져올 수 있다. 단, `@Autowired`는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다. 
> `@Autowired`는 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.        

-----

이전 글 - [*2.3. 개발자를 위한 테스팅 프레임워크 JUnit*](./2.3.%20개발자를%20위한%20테스팅%20프레임워크%20JUnit.md)                            
**다음 글 - [*2.5. 학습 테스트로 배우는 스프링*](./2.5.%20학습%20테스트로%20배우는%20.md)** 
