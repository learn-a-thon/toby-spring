###### 5장 서비스 추상화
# 5.1. 사용자 레벨 관리 기능 추가

지금까지 만들었던 `UserDao`를 다수의 회원이 가입할 수 있는 인터넷 서비스의 사용자 관리 모듈에 적용한다고 생각해보자. 구현할 비즈니스 로직은 다음과 같다. 
* 사용자의 레벨은 `BASIC`, `SILVER`, `GOLD` 세 가지 중 하나다. 
* 사용자가 처음 가입하면 `BASIC` 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다. 
* 가입 후 50회 이상 로그인을 하면 `BASIC`에서 `SILVER` 레벨이 된다. 
* `SILVER` 레벨이면서 30 번 이상 추천을 받으면 `GOLD` 레벨이 된다. 
* 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다. 

<br/>

### Level 이늄

먼저 `User` 클래스에 사용자의 레벨을 저장할 필드를 추가하자. 만약 다음과 같이 상수 값을 정해놓고 `int` 타입으로 레벨을 사용한다고 해보자. 

```java
class User {
    private static final int BASIC = 1;
    private static final int SILVER = 2;
    private static final int GOLD = 3;
    
    int level;
    
    public void setLevel(int level) {
        this.level = level;
    }
}
```

BASIC, SILVER, GOLD처럼 의미있는 상수도 정의했으니 깔끔하게 코드를 작성할 수 있긴 하다. 문제는 `level`의 타입이 `int`이기 때문에 다음처럼 다른 종류의 정보를 
넣는 실수를 해도 컴파일러가 체크해주지 못한다는 점이다. 

```java
user1.setLevel(1000);
```

그래서 숫자 타입을 직접 사용하는 것보다는 Enum을 이용하는게 안전하고 편리하다. 

```java
public enum Level {
    BASIC(1), SILVER(2), GOLD(3);
    
    private final int value;
    
    Level(int value) {
        this.value = value;
    }
    
    public int intValue() {
        return value;
    }
    
    public static Level valueOf(int value) {
        switch(value) {
            case 1: return BASIC;
            case 2: return SILVER;
            case 3: return GOLD;
            default: throw mew AssertionError("Unknown value: " + value);
        }
    }
}
```

이렇게 만들어진 `Level` 이늄은 내부에는 DB에 저장할 `int` 타입의 값을 갖고 있지만, 겉으로는 `Level` 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다. 

<br/>

### User 필드 추가

이렇게 만든 `Level` 타입의 변수와 로그인 횟수, 추천수를 `User` 클래스에 추가하자. 

```java
@Getter
@Setter
public class User {
    String id;
    String name;
    String password;
    Level level;
    int login;
    int recommend;
  
    public User(String id, String name, String password, Level level) {
        this.id = id;
        this.name = name;
        this.password = password;
        this.level = level;
        this.login = login;
        this.recommend = recommend;
    }
  
    public Level getLevel() {
        return level;
    }
  
    public void setLevel(Level level) {
        this.level = level;
    }
    ...
}
```

<br/>

### UserDaoTest 수정

`UserDaoJdbc`와 테스트에도 필드를 추가한다. 먼저 텍스트 픽스처로 만든 user1, user2, user3에 새로 추가된 세 필드의 값을 넣는다. 
그리고 두 개의 `User` 오브젝트 필드 값이 모두 같은지 비교하는 `checkSameUser()` 메소드에 새로운 필드를 비교하는 코드를 추가한다. 

```java
public class UserDaoTest {
    ...
    @Before
    public void setUp() {
        this.user1 = new User("gyumee", "박성철", "springno1", Level.BASIC, 1, 0);
        this.user2 = new User("leegw700", "이길원", "springno2", Level.SILVER, 55, 10);
        this.user3 = new User("bumjin", "박범진", "springno3", Level.GOLD, 100, 40);
    }
  
    private void checkSameUser(User user1, User user2) {
        assertThat(user1.getId(), is(user2.getId()));
        assertThat(user1.getName(), is(user2.getName()));
        assertThat(user1.getPassword(), is(user2.getPassword()));
        assertThat(user1.getLevel(), is(user2.getLevel()));
        assertThat(user1.getLogin(), is(user2.getLogin()));
        assertThat(user1.getRecommend(), is(user2.getRecommend()));
    }
}
```
> 새로운 필드를 포함하는 User 필드 값 검증 메소드

```java
@Test
public void addAndGet() {
    ...
    User userget1 = dao.get(user1.getId());
    checkSameUser(userget1, user1);
  
    User userget2 = dao.get(user2.getId());
    checkSameUser(userget2, user2);
}
```
> checkSameUser() 메소드를 사용하도록 만든 addAndGet() 메소드

<br/>

### UserDaoJdbc 수정

이제 테스트가 성공하도록 `UserDaoJdbc` 클래스를 수정할 차례다. 등록을 위한 INSERT 문장이 들어있는 `add()` 메소드의 SQL과 각종 조회 작업에 사용되는 User 오브젝트 매핑용 
콜백인 `userMapper`에 추가된 필드를 넣는다. 

```java
public class UserDaoJdbc implements UserDao {
    ...
    private RowMapper<User> userMapper = new RowMapper<User>() {
        public User mapRow(ResultSet rs, int rowNum) throws SQLException {
            User user = new User();
            user.setId(rs.getString("id"));
            user.setName(rs.getString("name"));
            user.setPassword(rs.getString("password"));
            user.setLevel(Level.valueOf(rs.getInt("level")));
            user.setLogin(rs.getInt("login"));
            user.setRecommend(rs.getInt("recommend"));
            return user;
        }
    };
  
    public void add(User user) {
        this.jdbcTemplate.update(
            "insert into users(id, name, password, level, login, recommend) values(?,?,?,?,?,?)", 
            user.getId(), user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend());
    }
}
```

여기서 중요한 것은 `Level` 타입의 `level` 필드를 사용하는 부분이다. Level 이늄은 오브젝트이므로 DB에 저장될 수 있는 SQL 타입이 아니다. 
따라서 DB에 저장 가능한 정수형 값으로 변환해줘야 한다. 각 Level 이늄의 DB 저장용 값을 얻기 위해서는 Level에 미리 만들어둔 `intValue()` 메소드를 사용한다. 
`add()` 메소드에서 이 메소드를 사용했다.                

반대로 조회를 했을 경우, `ResultSet`에서는 DB의 타입인 `int`로 level 정보를 가져온다. 이 값을 User의 `setLevel()` 메소드에 전달하면 타입이 일치하지 않는다는 
에러가 발생할 것이다. 이때는 Level의 스태틱 메소드인 `valueOf()`을 이용해 `int` 타입의 값을 `Level` 이늄 오브젝트로 만들어서 `setLevel()` 메소드에 넣어줘야 한다. 

<br/>

### 수정 기능 테스트 추가 

사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 수정할 정보가 담긴 `User` 오브젝트를 전달하면 `id`를 참고해서 사용자를 찾아 필드 정보를 UPDATE 문을 
이용해 모두 변경해주는 메소드를 하나 만들겠다. 

```java
@Test
public void update() {
    dao.deleteAll();
    
    dao.add(user1);
  
    user1.setName("김맷돌");
    user1.setPassword("hi~~");
    user1.setLevel(Level.GOLD);
    user1.setLogin(1000);
    user1.setRecommend(999);
    dao.update(user1);
    
    User user1update = dao.get(user1.getId());
    checkSameUser(user1, user1update);
}
```

<br/>

### UserDao와 UserDaoJdbc 수정

`UserDao` 인터페이스와 `UserDaoJdbc`에 각각 `update()` 메소드를 추가한다.

```java
public interface UserDao {
    ...
    public void update(User user1);
}
```

```java
public void update(User user) {
    this.jdbcTemplate.update(
        "update users set name = ?, password = ?, level = ?, login = ?, recommend = ?, where id = ?", 
        user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend(), user.getId());
}
```

<br/>

### 수정 테스트 보완 

추가한 기능을 바탕으로 테스트를 보완하자. 

```java
@Test
public void update() {
    dao.deleteAll();
    
    dao.add(user1);  // 수정할 사용자
    dao.add(user2);  // 수정하지 않을 사용자
  
    user1.setName("김맷돌");
    user1.setPassword("hi~~");
    user1.setLevel(Level.GOLD);
    user1.setLogin(1000);
    user1.setRecommend(999);
  
    dao.update(user1);
    
    User user1update = dao.get(user1.getId());
    checkSameUser(user1, user1update);
    User user2same = dao.get(user2.getId());
    checkSameUser(user2, user2same);
}
```

-----

**다음 글 - [*5.2. 트랜잭션 서비스 추상화*](./5.2.%20트랜잭션%20서비스%20추상화.md)**
